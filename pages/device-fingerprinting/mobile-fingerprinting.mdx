---
description: Use Keyri's immutable device fingerprinting system to stop fraud, starting with account opening, account takeovers, bot prevention, and promo abuse.
---

import {Tab, Tabs} from 'nextra-theme-docs';

# Overview

Keyri offers best in class mobile fingerprinting and device integrity verification, accessible in as little as one line of code.

The SDK will:

- Generate a unique fingerprint which persists even when the app is deleted
This is something many developers struggle with. It's quite easy to keep a fingerprint UNTIL the app is deleted, but persistence across installations is tricky. This is exacerbated by the ease with which bad actors can clear out records in the iOS Keychain or Android Keystore.
- Send the information to our API using a strong cryptography technique which ensures the information cannot be tampered with or intercepted
Note: This information will be available on the Keyri Dashboard
- Verify device integrity to stop bad actors in their tracks. We have checks to protect against
- Jailbreaks
- Malicious side-loaded applications
- Method swizzling
- Code tampering
- Emulators
- Optional protection against:
- VPN
- Blocklist usage
- TOR

## Requirements

- iOS: iOS 14+
- Android: API Level 23

## Implementation and Installation

<iframe
    width='560'
    height='315'
    src='https://www.youtube.com/embed/NDMjEIrpWis'
    title='YouTube video player'
    frameborder='0'
    allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share'
    allowfullscreen
></iframe>

- iOS: https://docs.keyri.com/mobile-sdks/ios
- Android: (https://docs.keyri.com/mobile-sdks/android)

### Methods

- `generateAssociationKey(username: String) -> p256Key`: Create a persistent (even on app deletion) record of a user
- `getAssociationKey(username: String) -> p256Key?`: Retrieve key for a given user, if the user has been created
- `listAssociationKeys() -> [String: p256Key]`: List the accounts that have been created
- `sign(data: Data for username: String) -> Signature`: Sign a piece of data with the user's key
- `sendEvent(username: String?, eventType: EventType, eventResult: EventResult)`: Send Keyri a fingerprint of the device

### Example: Protecting Registration/Signup

The following example protects your registration/signup flow. Regardless of the credentials that the user inputs when trying to create a new account (like a new username), the Keyri methods included here will detect whether that device has already registered an account, and if so, suggest to the user to log in with that existing account rather than create a new one. Of course, you can implement other logic like allowing up to two accounts, blocking certain accounts altogether, etc. All you're getting when running `listUniqueAccounts()` is a useful, reliable array of accounts associated with that device, and you can parse and act upon it however you'd like.

<Tabs items={['Swift', 'Kotlin', 'Dart/Flutter', 'React Native']}>
<Tab>
```swift copy
func registerUser(username: String) throws {
    if let list = Keyri().listAssociationKey() {
        if let existingUsername = list.keys.first {
            // Alert user that there is an existing user, and encourage them to sign in here
        }
    } else {
       let key = try Keyri().generateAssociationKey(username: username)
       // Then run your regular registration process
       // Optionally, do something else with the key that just got generated.
       // Keyri Handles saving the key in the Secure Enclave for you
       // For example, you can later use this key pair to passwordlessly authenticate the user
    }
}
````
</Tab>
<Tab>
```kotlin copy
suspend fun registerUser(username: String, password: String) {
    val keyri = Keyri(this@MainActivity, appKey, publicApiKey)
    val keys = keyri.listAssociationKey()

    if (keys.isNotEmpty()) {
        // Alert user that there is an existing user, and encourage them to sign in here
    } else {
        val key = keyri.generateAssociationKey(publicUserId = username)
        // Then run your regular registration process
        // Optionally, do something else with the key that just got generated.
        // Keyri Handles saving the key in the Secure Enclave for you
        // For example, you can later use this key pair to passwordlessly authenticate the user
    }
}
````
</Tab>
<Tab>
```dart copy
void registerUser(String username, String password) {
    Keyri keyri = Keyri();

    // Call this method before accessing the SDK's methods
    await keyri.initialize(appKey, publicApiKey);

    keyri.listAssociationKey()
        .then((keys) => {
            if (keys.isNotEmpty()) {
                // Alert user that there is an existing user, and encourage them to sign in here
            } else {
                String key = keyri.generateAssociationKey(username)
                // Then run your regular registration process
                // Optionally, do something else with the key that just got generated.
                // Keyri Handles saving the key in the Secure Enclave for you
                // For example, you can later use this key pair to passwordlessly authenticate the user
            }
        });
    }
````
</Tab>
<Tab>
```javascript copy
async function registerUser(username: string, password: string) {
    // Call this method before access to SDK's methods
    await Keyri.initialize(appKey, publicApiKey);

    const keys = await Keyri.listAssociationKey();

    if (keys?.length > 0) {
        // Alert user that there is an existing user, and encourage them to sign in here
    } else {
        const key = await Keyri.generateAssociationKey(username);
        // Then run your regular registration process
        // Optionally, do something else with the key that just got generated.
        // Keyri Handles saving the key in the Secure Enclave for you
        // For example, you can later use this key pair to passwordlessly authenticate the user
    }
}
````
</Tab>
</Tabs>

### Example: Full Serverside Fingerprinting
<Tabs items={['Swift', 'Kotlin']}>
<Tab>
```swift copy
func createUser(username: String) -> P256.Signing.PublicKey? {
    If Keyri().listAssociationKeys().count < MAX_ACCOUNT_LIMIT {
        let key = Keyri().generateAssociationKey(username: username)

        // Optionally sign custom data with the key at this stage
        // remember, the key can always be retrieved with getAssociationKey
        Keyri().sendEvent(eventType: .login, success: true)
        Return key
    } else {
    // Alert user that they’re exceeding the limit here
    return nil
    }
}
````
</Tab>
<Tab>
```kotlin copy
suspend fun createUser(username: String): String? {
    val keyri = Keyri(this@MainActivity, appKey, publicApiKey)

    return if (keyri.listAssociationKey().size < MAX_ACCOUNT_LIMIT) {
        val key = keyri.generateAssociationKey(username)

        // Optionally sign custom data with the key at this stage
        // remember, the key can always be retrieved with getAssociationKey
        keyri.sendEvent(
            publicUserId: username,
            eventType: EventType.Login,
            eventResult: FingerprintLogResult.Success
        )

        key
    } else {
        // Alert user that they're exceeding the limit here
        null
    }
}
````
</Tab>
</Tabs>

## Android Accounts Backup

Preserving user-device fingerprints even after your app is deleted and re-installed requires additional backup configuration steps. This document will help you set up your account backup configuration.

You can find a comparison of Key/Value Backup and Auto Backup here: [Android Backup Overview](https://developer.android.com/guide/topics/data/backup).

Keyri backup file `keyri_backup_prefs` is a SharedPreferences file that contains Keyri accounts. You need to keep this file after app uninstall to prevent a loss of accounts. There are two options for how to do it.

### Keyri fingerprint-based backup

To increase backup efficiency and stability, you can use our Keyri fingerprint-based backup. This should prevent common Android backup issues and possible workarounds. Go to your service on [Keyri Dashboard](https://app.keyri.com), then in the "Fraud analytics" section, select `Setup & Credentials` tab and copy your `Fingerprint Api Key` value. Save it to your Android project secrets and use it during the initialization of the SDK object:

```kotlin
val appKey = "Your App Key"
val publicApiKey = "Your Fingerprint Api Key"

val keyri = Keyri(this@MainActivity, appKey, publicApiKey)
```

### Android Auto Backup

Auto Backup for Apps automatically backs up a user's data from apps that target and run on Android 6.0 (API level 23) or higher.

Make sure that backup is not disabled in your application. `allowBackup` should not be false. The default value is true but to make your intentions clear, we recommend explicitly setting the attribute in your manifest as shown below:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application android:allowBackup="true">
        ...
    </application>
</manifest>
```

[](https://github.com/Keyri-Co/keyri-android-whitelabel-sdk/blob/master/keyrisdk/src/main/java/com/keyrico/keyrisdk/backup/BACKUP.md#control-backup-on-android-11-and-lower)**Control backup on Android 11 and lower**

Follow the steps in this section to include or exclude files that are backed up on devices running Android 11 (API level 30) or lower.

1.  In `AndroidManifest.xml`, add the `android:fullBackupContent` attribute to the `<application>` element. This attribute points to an XML file that contains backup rules. For example:

```xml
<application android:fullBackupContent="@xml/backup_rules">
    ...
</application>
```

2. Create an XML file called `@xml/backup_rules` in the `res/xml/` directory. Inside the file, add rules with the `<include>` and `<exclude>` elements. The following sample backs up all shared preferences except device.xml:

```xml
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <include domain="sharedpref" path="." />
    <exclude domain="sharedpref" path="device.xml" />
</full-backup-content>
```

If you have more granular control over sharedPref backups, make sure you have included an `keyri_backup_prefs.xml` file.

[](https://github.com/Keyri-Co/keyri-android-whitelabel-sdk/blob/master/keyrisdk/src/main/java/com/keyrico/keyrisdk/backup/BACKUP.md#control-backup-on-android-12-or-higher)

**Control backup on Android 12 or higher**

If your app targets Android 12 (API level 31) or higher, follow the steps in this section to include or exclude files that are backed up on devices that are running Android 12 or higher.

1.  In `AndroidManifest.xml`, add the `android:dataExtractionRules` attribute to the `<application>` element. This attribute points to an XML file that contains backup rules. For example:

```xml
<application android:dataExtractionRules="backup_rules.xml">
    ...
</application>
```

2. Create an XML file called `backup_rules.xml` in the `res/xml/` directory. Inside the file, add rules with the `<include>` and `<exclude>` elements. The following sample backs up all shared preferences `except device.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="sharedpref" path="." />
        <exclude domain="sharedpref" path="device.xml" />
    </cloud-backup>
</data-extraction-rules>
```

If you have more granular control over sharedPref backups, make sure you have include `keyri_backup_prefs.xml` file.

Check for more details on [Back up user data with Auto Backup](https://developer.android.com/guide/topics/data/autobackup).

### Key/Value Backup (Android Backup Service)

Android Backup Service provides cloud storage backup and restore for key-value data in your Android app. During a key-value backup operation, the app's backup data is passed to the device's backup transport. If the device is using the default Google backup transport, then the data is passed to Android Backup Service for archiving. Data is limited to 5MB per user of your app. There is no charge for storing backup data.

`Note: Key-value backup requires you to write code to define your backup content explicitly, while Auto Backup requires no code and will back up entire files. Most apps should use Auto Backup to implement backup and restore. Your app can implement Auto Backup or key-value backup, but not both.`

[](https://github.com/Keyri-Co/keyri-android-whitelabel-sdk/blob/master/keyrisdk/src/main/java/com/keyrico/keyrisdk/backup/BACKUP.md#implement-key-value-backup)**Implement key-value backup**

To back up your app data, you need to implement a backup agent. Your backup agent is called by the Backup Manager both during backup and restore.

To implement a backup agent, you must:

1.  Declare your backup agent in your manifest file with the android\:backupAgent attribute.

2.  Define a backup agent by doing one of the following:


*   Extending BackupAgent The BackupAgent class provides the central interface that your app uses to communicate with the Backup Manager. If you extend this class directly, you must override `onBackup()` and `onRestore()` to handle the backup and restore operations for your data.

*   Extending BackupAgentHelper The BackupAgentHelper class provides a convenient wrapper around the `BackupAgent` class, minimizing the amount of code you need to write. In your `BackupAgentHelper`, you must use one or more helper objects, which automatically back up and restore certain types of data, so that you don't need to implement `onBackup()` and `onRestore()`. Unless you need full control over your app's backups, we recommend using the `BackupAgentHelper` to handle your app's backups.

Android currently provides backup helpers that will back up and restore complete files from SharedPreferences and internal storage.

You can implement your own backup according to the documentation: [Back up key-value pairs with Android Backup Service](https://developer.android.com/guide/topics/data/keyvaluebackup). In this case just include `keyri_backup_prefs` string to your BackupAgentHelper as shown below:

```kotlin
class MyBackupAgent : BackupAgentHelper() {

    override fun onCreate() {
        val helper = SharedPreferencesBackupHelper(this, "your prefs files (optional)", "keyri_backup_prefs")

        addHelper("YOUR BACKUP KEY", helper)
    }
}
```

After it just add your `MyBackupAgent` to `AndroidManifest.xml`:

```xml
<manifest>
    ...
    <application android:backupAgent="MyBackupAgent">
        <activity>
            ...
        </activity>
    </application>
</manifest>
```

Or you can just use our [KeyriPrefsBackupAgent](https://github.com/Keyri-Co/keyri-android-whitelabel-sdk/blob/master/keyrisdk/src/main/java/com/keyrico/keyrisdk/backup/KeyriPrefsBackupAgent.kt) which implements the necessary logic under the hood as shown below:&#x20;

```xml
<manifest>
    ...
    <application android:backupAgent="com.keyrico.keyrisdk.backup.KeyriPrefsBackupAgent">
        <activity>
            ...
        </activity>
    </application>
</manifest>
```

### Testing backup

See [Test backup and restore](https://developer.android.com/guide/topics/data/testingbackup) to test backup of Keyri accounts.

## Privacy Disclosures

When submitting your Android app that uses the Keyri SDK for fingerprinting, be sure to disclose the following data collection practice:
| Data Types | Collected | Shared | Processed ephemerally | Required or Optional | Purposes |
| --- | --- | --- | --- | --- | --- |
| Device or other IDs | Yes | Yes | No | Required | Analytics |

An analogous disclosure is not required for iOS apps, since the device data is not used by Keyri for cross-app tracking.
