---
description: Permanently associate your users with their devices to improve UX and reduce fraud
---

import { Tab, Tabs } from 'nextra-theme-docs';

# Mobile app fingerprinting

One major utility of the Keyri mobile SDKs is strong device fingerprinting; in other words, stably associating a given device on which your app is installed to a given user account or set of user accounts, then reading those associations when you want to in order to handle different situations. The fingerprint persists even if the user deletes your app and re-installs it.

All Keyri device fingerprinting functionality and intelligence takes place within the confines of your mobile app, through Keyri SDK methods. Custom logic can be set up on your mobile app or dictated by your backend based on the outputs of Keyri's mobile fingerprint-related methods.

This device fingerprinting and fingerprint reading functionality is independent of the authentication system you use, and the fingerprinting methods outlined below can be embedded into your existing signup and login functions as additional sources of data that enable further conditional app behavior.

## Implementation

<iframe
  width='560'
  height='315'
  src='https://www.youtube.com/embed/NDMjEIrpWis'
  title='YouTube video player'
  frameborder='0'
  allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share'
  allowfullscreen
></iframe>

The two primary Keyri SDK methods used to implant and retrieve user-related device fingerprints are `generateAssociationKey(userIdentifier)` and `listUniqueAccounts()` respectively. The former is used to create a key pair for a user and return a public key that you can either ignore or save to your database for further use, such as continuous authentication. The latter is simply used to list the key pairs present on the device, associated with your app, as well as the user identifiers they are associated with, returning an array. If this array is empty, it is highly likely that the user has only recently installed your app and is a legitimate user, thereby allowing them to complete registration with no added friction. On the other hand, if this array is not empty, they can be confidently directed to log into their existing account.

### Example: Protecting Registration/Signup

The following example protects your registration/signup flow. Regardless of the credentials that the user inputs when trying to create a new account (like a new username), the Keyri methods included here will detect whether that device has already registered an account, and if so, suggest to the user to log in with that existing account rather than create a new one. Of course, you can implement other logic like allowing up to two accounts, blocking certain accounts altogether, etc. All you're getting when running `listUniqueAccounts()` is a useful, reliable array of accounts associated with that device, and you can parse and act upon it however you'd like.

<Tabs items={['Swift', 'Kotlin', 'Dart/Flutter', 'React Native']}>
<Tab>
```swift copy
func registerUser(username: String) throws {
    if let list = Keyri().listAssociationKey() {
        if let existingUsername = list.keys.first {
            // Alert user that there is an existing user, and encourage them to sign in here
        }
    } else {
       let key = try Keyri().generateAssociationKey(username: username)
       // Then run your regular registration process
       // Optionally, do something else with the key that just got generated.
       // Keyri Handles saving the key in the Secure Enclave for you
       // For example, you can later use this key pair to passwordlessly authenticate the user
    }
}
````
</Tab>
<Tab>
```kotlin copy
fun registerUser(username: String, password: String) {
    val keyri = Keyri(this@MainActivity)
    val keys = keyri.listAssociationKey()

    if (keys.isNotEmpty()) {
        // Alert user that there is an existing user, and encourage them to sign in here
    } else {
        val key = keyri.generateAssociationKey(publicUserId = username)
        // Then run your regular registration process
        // Optionally, do something else with the key that just got generated.
        // Keyri Handles saving the key in the Secure Enclave for you
        // For example, you can later use this key pair to passwordlessly authenticate the user
    }
}
````
</Tab>
<Tab>
```dart copy
void registerUser(String username, String password) {
    Keyri keyri = Keyri()

    keyri.listAssociationKey()
        .then((keys) => {
            if (keys.isNotEmpty()) {
                // Alert user that there is an existing user, and encourage them to sign in here
            } else {
                String key = keyri.generateAssociationKey(username)
                // Then run your regular registration process
                // Optionally, do something else with the key that just got generated.
                // Keyri Handles saving the key in the Secure Enclave for you
                // For example, you can later use this key pair to passwordlessly authenticate the user
            }
    });
}
````
</Tab>
<Tab>
```javascript copy
function registerUser(username: string, password: string) {
    const keys = Keyri.listAssociationKey();

    if (keys?.length > 0) {

// Alert user that there is an existing user, and encourage them to sign in here
} else {
const key = Keyri.generateAssociationKey(username);
// Then run your regular registration process
// Optionally, do something else with the key that just got generated.
// Keyri Handles saving the key in the Secure Enclave for you
// For example, you can later use this key pair to passwordlessly authenticate the user
}
}
```
</Tab>
</Tabs>

## Android Accounts Backup

Preserving user-device fingerprints even after your app is deleted and re-installed requires additional backup configuration steps. This document will help you set up your account backup configuration.

You can find a comparison of Key/Value Backup and Auto Backup here: [Android Backup Overview](https://developer.android.com/guide/topics/data/backup).

Keyri backup file `keyri_backup_prefs` is a SharedPreferences file that contains Keyri accounts. You need to keep this file after app uninstall to prevent a loss of accounts. There are two options for how to do it.

### Android Auto Backup

Auto Backup for Apps automatically backs up a user's data from apps that target and run on Android 6.0 (API level 23) or higher.

Make sure that backup is not disabled in your application. `allowBackup` should not be false. The default value is true but to make your intentions clear, we recommend explicitly setting the attribute in your manifest as shown below:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application android:allowBackup="true">
        ...
    </application>
</manifest>
```

[](https://github.com/Keyri-Co/keyri-android-whitelabel-sdk/blob/master/keyrisdk/src/main/java/com/keyrico/keyrisdk/backup/BACKUP.md#control-backup-on-android-11-and-lower)**Control backup on Android 11 and lower**

Follow the steps in this section to include or exclude files that are backed up on devices running Android 11 (API level 30) or lower.

1.  In `AndroidManifest.xml`, add the `android:fullBackupContent` attribute to the `<application>` element. This attribute points to an XML file that contains backup rules. For example:

```xml
<application android:fullBackupContent="@xml/backup_rules">
    ...
</application>
```

2. Create an XML file called `@xml/backup_rules` in the `res/xml/` directory. Inside the file, add rules with the `<include>` and `<exclude>` elements. The following sample backs up all shared preferences except device.xml:

```xml
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <include domain="sharedpref" path="." />
    <exclude domain="sharedpref" path="device.xml" />
</full-backup-content>
```

If you have more granular control over sharedPref backups, make sure you have included an `keyri_backup_prefs.xml` file.

[](https://github.com/Keyri-Co/keyri-android-whitelabel-sdk/blob/master/keyrisdk/src/main/java/com/keyrico/keyrisdk/backup/BACKUP.md#control-backup-on-android-12-or-higher)

**Control backup on Android 12 or higher**

If your app targets Android 12 (API level 31) or higher, follow the steps in this section to include or exclude files that are backed up on devices that are running Android 12 or higher.

1.  In `AndroidManifest.xml`, add the `android:dataExtractionRules` attribute to the `<application>` element. This attribute points to an XML file that contains backup rules. For example:

```xml
<application android:dataExtractionRules="backup_rules.xml">
    ...
</application>
```

2. Create an XML file called `backup_rules.xml` in the `res/xml/` directory. Inside the file, add rules with the `<include>` and `<exclude>` elements. The following sample backs up all shared preferences `except device.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="sharedpref" path="." />
        <exclude domain="sharedpref" path="device.xml" />
    </cloud-backup>
</data-extraction-rules>
```

If you have more granular control over sharedPref backups, make sure you have include `keyri_backup_prefs.xml` file.

Check for more details on [Back up user data with Auto Backup](https://developer.android.com/guide/topics/data/autobackup).

### Key/Value Backup (Android Backup Service)

Android Backup Service provides cloud storage backup and restore for key-value data in your Android app. During a key-value backup operation, the app's backup data is passed to the device's backup transport. If the device is using the default Google backup transport, then the data is passed to Android Backup Service for archiving. Data is limited to 5MB per user of your app. There is no charge for storing backup data.

`Note: Key-value backup requires you to write code to define your backup content explicitly, while Auto Backup requires no code and will back up entire files. Most apps should use Auto Backup to implement backup and restore. Your app can implement Auto Backup or key-value backup, but not both.`

[](https://github.com/Keyri-Co/keyri-android-whitelabel-sdk/blob/master/keyrisdk/src/main/java/com/keyrico/keyrisdk/backup/BACKUP.md#implement-key-value-backup)**Implement key-value backup**

To back up your app data, you need to implement a backup agent. Your backup agent is called by the Backup Manager both during backup and restore.

To implement a backup agent, you must:

1.  Declare your backup agent in your manifest file with the android\:backupAgent attribute.

2.  Define a backup agent by doing one of the following:


*   Extending BackupAgent The BackupAgent class provides the central interface that your app uses to communicate with the Backup Manager. If you extend this class directly, you must override `onBackup()` and `onRestore()` to handle the backup and restore operations for your data.

*   Extending BackupAgentHelper The BackupAgentHelper class provides a convenient wrapper around the `BackupAgent` class, minimizing the amount of code you need to write. In your `BackupAgentHelper`, you must use one or more helper objects, which automatically back up and restore certain types of data, so that you don't need to implement `onBackup()` and `onRestore()`. Unless you need full control over your app's backups, we recommend using the `BackupAgentHelper` to handle your app's backups.

Android currently provides backup helpers that will back up and restore complete files from SharedPreferences and internal storage.

You can implement your own backup according to the documentation: [Back up key-value pairs with Android Backup Service](https://developer.android.com/guide/topics/data/keyvaluebackup) . In this case just include `keyri_backup_prefs` string to your BackupAgentHelper as shown below:

```kotlin
class MyBackupAgent : BackupAgentHelper() {

    override fun onCreate() {
        val helper = SharedPreferencesBackupHelper(this, "your prefs files (optional)", "keyri_backup_prefs")

        addHelper("YOUR BACKUP KEY", helper)
    }
}
```

After it just add your `MyBackupAgent` to `AndroidManifest.xml`:

```xml
<manifest>
    ...
    <application android:backupAgent="MyBackupAgent">
        <activity>
            ...
        </activity>
    </application>
</manifest>
```

Or you can just use our [KeyriPrefsBackupAgent](https://github.com/Keyri-Co/keyri-android-whitelabel-sdk/blob/master/keyrisdk/src/main/java/com/keyrico/keyrisdk/backup/KeyriPrefsBackupAgent.kt) which implements the necessary logic under the hood as shown below:&#x20;

```xml
<manifest>
    ...
    <application android:backupAgent="com.keyrico.keyrisdk.backup.KeyriPrefsBackupAgent">
        <activity>
            ...
        </activity>
    </application>
</manifest>
```

### Testing backup

See [Test backup and restore](https://developer.android.com/guide/topics/data/testingbackup) to test backup of Keyri accounts.
