---
description: Keyri's Android SDK handles secure cryptographic key generation, key storage, encryption, API communications, and all other functions for authentication and fraud prevention.
---

import { Tab, Tabs } from 'nextra-theme-docs';
import { AndroidSDKVersion } from 'components/AndroidSDKVersion';

## Keyri Android SDK

The latest source code of the Keyri Android SDK can be found here: https://github.com/Keyri-Co/keyri-android-whitelabel-sdk/releases

## System Requirements

- Android API level 23 or higher
- AndroidX compatibility
- Kotlin's coroutines compatibility

Note: Your app does not have to be written in Kotlin to integrate this SDK, but it must be able to depend on Kotlin functionality.

## Integration

Add the Keyri SDK dependency to your module `build.gradle` file and sync project, replacing `VERSION_NUMBER` with the latest version number, currently **<AndroidSDKVersion />**:

```kotlin copy
dependencies {
    // ...
    implementation("com.keyri:keyrisdk:VERSION_NUMBER")
}
```

If you are using Java, you also need to add the following dependency to your module:

```kotlin copy
dependencies {
    // ...
    implementation("com.keyri:keyrisdk:VERSION_NUMBER")
    implementation("com.keyri:keyrisdk-java:VERSION_NUMBER")
}
```

### Option 1 - App Links

To handle Android App Links \(e.g., for QR login straight from the user's built-in camera app\) you need to define the following intent-filter block in your `AndroidManifest.xml`:

```xml copy
<application...>
<!-- ...  -->
    <activity...>
        <!-- ...  -->
        <intent-filter android:autoVerify="true">
            <action android:name="android.intent.action.VIEW" />

            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />

        <data android:host="${domainName}" android:scheme="https" />
        </intent-filter>
    </activity>
</application>
```

This will handle all links with the following scheme: `https://{yourCompany}.onekey.to?sessionId={sessionId}`

**Note:** Keyri will create your `https://{yourCompany}.onekey.to` page automatically once you configure it in the [dashboard](https://app.keyri.com)

In the activity where the processing of links is declared, you need to add handlers in the `onNewIntent()` and `onCreate()` methods, and pass `sessionId` to `easyKeyriAuth` method:

<Tabs items={['Kotlin', 'Java']}>
<Tab>
```kotlin copy
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    intent.data?.let(::processLink)
}

override fun onNewIntent(intent: Intent) {
    super.onNewIntent(intent)
    processLink(intent.data)
}

private fun processLink(data: Uri?) {
    data?.getQueryParameters("sessionId")?.firstOrNull()?.let { sessionId ->
        lifecycleScope.launch(Dispatchers.IO) {
            // Using ActivityResult API:
            easyKeyriAuth(
                this,
                easyKeyriAuthLauncher,
                "[Your appKey]", // Get this value from the Keyri Dashboard
                "[Your publicApiKey]", // Get this optional value from the Keyri Dashboard for Fraud Prevention
                "[Your serviceEncryptionKey]", // Get this optional value from the Keyri Developer Portal for Fraud Prevention
                "Custom payload here",
                "public-User-Id", // publicUserId is optional
            )

            // Or with on activityResult:
            // This will call an activity that will return a result
            // Handle this result in onActivityResult function
            easyKeyriAuth(
                this,
                REQUEST_CODE,
                "[Your appKey]", // Get this value from the Keyri Dashboard
                "[Your publicApiKey]", // Get this optional value from the Keyri Dashboard for Fraud Prevention
                "[Your serviceEncryptionKey]", // Get this optional value from the Keyri Developer Portal for Fraud Prevention
                "Custom payload here",
                "public-User-Id", // publicUserId is optional
            )
        }
    } ?: Log.e("Keyri", "Failed to process link")
}
```
</Tab>
<Tab>
```java copy
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    processLink(this.getIntent().getData());
}

@Override
protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    processLink(intent.getData());
}

private void processLink(@Nullable Uri data) {
    String sessionId = data.getQueryParameters("sessionId").get(0);

    if (sessionId != null) {
        EasyKeyriAuth.easyKeyriAuth(
            this,
            easyKeyriAuthLauncher,
            "[Your appKey]", // Get this value from the Keyri Dashboard
            "[Your publicApiKey]", // Get this optional value from the Keyri Dashboard for Fraud Prevention
            "[Your serviceEncryptionKey]", // Get this optional value from the Keyri Developer Portal for Fraud Prevention
            "Custom payload here",
            "public-User-Id" // publicUserId is optional
        );

        EasyKeyriAuth.easyKeyriAuth(
            this,
            REQUEST_CODE,
            "[Your appKey]", // Get this value from the Keyri Dashboard
            "[Your publicApiKey]", // Get this optional value from the Keyri Dashboard for Fraud Prevention
            "[Your serviceEncryptionKey]", // Get this optional value from the Keyri Developer Portal for Fraud Prevention
            "Custom payload here",
            "public-User-Id" // publicUserId is optional
        );
    } else {
        Log.e("Keyri", "Failed to process link");
    }
}
```
</Tab>
</Tabs>

Alternatively, you can process the entire flow yourself:

<Tabs items={['Kotlin', 'Java']}>
<Tab>
```kotlin copy
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    intent.data?.let(::process)
}

override fun onNewIntent(intent: Intent) {
    super.onNewIntent(intent)
    process(intent.data)
}

private fun process(uri: Uri?) {
    uri?.getQueryParameters("sessionId")?.firstOrNull()?.let { sessionId ->
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val appKey = "[Your appKey]" // Get this value from the Keyri Dashboard
                val publicApiKey =
                    "[Your publicApiKey]" // Get this optional value from the Keyri Dashboard for Fraud Prevention
                val serviceEncryptionKey =
                    "[Your serviceEncryptionKey]" // Get this optional value from the Keyri Developer Portal for Fraud Prevention
                val publicUserId = "public-User-Id" // publicUserId is optional
                val payload = "Custom payload here"

                // Be sure to import the SDK at the top of the file
                val keyri = Keyri(this@MainActivity, appKey, publicApiKey, serviceEncryptionKey)

                keyri.initiateQrSession(sessionId, publicUserId)
                    .onSuccess { session ->
                        // You can optionally create a custom screen and pass the session ID there. We recommend this approach for large enterprises
                        val result =
                            keyri.initializeDefaultScreen(supportFragmentManager, session, payload)
                                .getOrThrow()

                        // In a real world example youâ€™d wait for user confirmation first
                        session.confirm(payload, this, ) // or session.deny(payload)
                    }

                // Process result
            } catch (e: Throwable) {
                Log.e("Keyri", "Authentication exception $e")
            }
        }
    } ?: Log.e("Keyri", "Failed to process link")
}
```
</Tab>
<Tab>
```java copy
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    processLink(this.getIntent().getData());
}

@Override
protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    processLink(intent.getData());
}

private void processLink(@Nullable Uri data) {
    String sessionId = data.getQueryParameters("sessionId").get(0);

    if (sessionId != null) {
        try {
            String appKey = "[Your appKey]"; // Get this value from the Keyri Dashboard
            String publicApiKey = "[Your publicApiKey]"; // Get this optional value from the Keyri Dashboard for Fraud Prevention
            String serviceEncryptionKey =
                "[Your serviceEncryptionKey]"; // Get this optional value from the Keyri Developer Portal for Fraud Prevention
            String publicUserId = "public-User-Id"; // publicUserId is optional
            String payload = "Custom payload here";

            // Be sure to import the SDK at the top of the file
            KeyriSdk keyri = new KeyriSdk(this, appKey, publicApiKey, serviceEncryptionKey);

            keyri.initiateQrSession(sessionId, publicUserId, new KeyriCallback<>() {
                @Override
                public void onComplete(KeyriSession result) {
                    // You can optionally create a custom screen and pass the session ID there. We recommend this approach for large enterprises
                    keyri.initializeDefaultConfirmationScreen(
                    getSupportFragmentManager(),
                    result,
                    payload,
                    new KeyriCallback<>() {
                        @Override
                        public void onComplete(String result) {
                            // Process result
                        }

                        @Override
                        public void onError(@Nullable Throwable throwable) {
                            // Process error
                        }
                    });

                    // In a real world example youâ€™d wait for user confirmation first
                    result.confirm(payload, this, true, new KeyriCallback<String>() {
                        @Override
                        public void onComplete(String result) {
                            // Process result
                        }

                        @Override
                        public void onError(@Nullable Throwable throwable) {
                            // Process error
                        }
                    }); // or session.deny(payload)
                }

                @Override
                public void onError(@Nullable Throwable throwable) {
                    // Process error
                }
            });
        } catch (Throwable e) {
            Log.e("Keyri", "Authentication exception $e");
        }
    } else {
        Log.e("Keyri", "Failed to process link");
    }
}
```
</Tab>
</Tabs>

**Note:** Keyri will set up the required `/.well-known/assetlinks.json` JSON at your `https://{yourSubdomain}.onekey.to` page as required by Android App Links handling. Details on this mechanism are described here: https://developer.android.com/training/app-links/verify-site-associations

### Option 2 - In-App Scanner

Add Scanner dependency to your module **build.gradle** file and sync project:

```kotlin copy
dependencies {
    // ...
    implementation("com.keyri:keyrisdk:$latestKeyriVersion")
    implementation("com.keyri:scanner:$latestKeyriVersion")
}
```

Use `AuthWithScannerActivity` built-in functionality to delegate authentication to SDK. You can use `ActivityResult API` or `onActivityResult`. Call `easyKeyriAuth` and pass `appKey`, `payload` and optional `publicApiKey` and `publicUserId`:

<Tabs items={['Kotlin', 'Java']}>
<Tab>
```kotlin copy
private val easyKeyriAuthLauncher =
    registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { activityResult ->
        val isSuccess = activityResult.resultCode == Activity.RESULT_OK
        // Handle authentication result
        // ...
    }

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    // ...
    binding.bAuthWithScanner.setOnClickListener {
        easyKeyriAuth(
            this,
            easyKeyriAuthLauncher,
            "[Your appKey]", // Get this value from the Keyri Dashboard
            "[Your publicApiKey]", // Get this value from the Keyri Dashboard, optional
            "[Your serviceEncryptionKey]", // Get this value from the Keyri Dashboard, optional
            "Custom payload here",
            "public-User-Id", // publicUserId is optional
        )
    }

    // Or with on activityResult:
    binding.bAuthWithScanner.setOnClickListener {
        // This will call an activity that will return a result
        // Handle this result in onActivityResult function
        easyKeyriAuth(
            this,
            REQUEST_CODE,
            "[Your appKey]", // Get this value from the Keyri Dashboard
            "[Your publicApiKey]", // Get this value from the Keyri Dashboard, optional
            "[Your serviceEncryptionKey]", // Get this value from the Keyri Dashboard, optional
            "Custom payload here",
            "public-User-Id", // publicUserId is optional
        )
    }
}
```
</Tab>
<Tab>
```java copy
private ActivityResultLauncher<Intent> easyKeyriAuthLauncher = registerForActivityResult(
    new ActivityResultContracts.StartActivityForResult(),
    result -> {
        boolean isSuccess = result.getResultCode() == Activity.RESULT_OK;
        // Handle authentication result
        // ...
});

@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // ...
    binding.bAuthWithScanner.setOnClickListener(v -> {
        EasyKeyriAuth.easyKeyriAuth(
            this,
            easyKeyriAuthLauncher,
            "[Your appKey]", // Get this value from the Keyri Dashboard
            "[Your publicApiKey]", // Get this value from the Keyri Dashboard, optional
            "[Your serviceEncryptionKey]", // Get this value from the Keyri Dashboard, optional
            "Custom payload here",
            "public-User-Id" // publicUserId is optional
        );
    });

    binding.bAuthWithScanner.setOnClickListener(v -> {
        EasyKeyriAuth.easyKeyriAuth(
            this,
            REQUEST_CODE,
            "[Your appKey]", // Get this value from the Keyri Dashboard
            "[Your publicApiKey]", // Get this value from the Keyri Dashboard, optional
            "[Your serviceEncryptionKey]", // Get this value from the Keyri Dashboard, optional
            "Custom payload here",
            "public-User-Id" // publicUserId is optional
        );
    });
}
```
</Tab>
</Tabs>

Or define a custom scanner UI/UX. You can use Firebase ML Kit, ZXing, your own scanner, or any other equivalent. All you need to do is convert to URI, and then you're free to process the response the same way we did above (notice the `process(uri)` function is exactly the same in both cases)

<Tabs items={['Kotlin', 'Java']}>
<Tab>
```kotlin copy
private fun scanQr() {
    // Your scanner implementation
    // Get link from QR and process it:
    process(uri)
}

private fun process(uri: Uri?) {
    uri?.getQueryParameters("sessionId")?.firstOrNull()?.let { sessionId ->
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val appKey = "[Your appKey]" // Get this value from the Keyri Dashboard
                val publicApiKey =
                    "[Your publicApiKey]" // Get this optional value from the Keyri Dashboard for Fraud Prevention
                val serviceEncryptionKey =
                    "[Your serviceEncryptionKey]" // Get this optional value from the Keyri Developer Portal for Fraud Prevention
                val publicUserId = "public-User-Id" // publicUserId is optional
                val payload = "Custom payload here"

                // Be sure to import the SDK at the top of the file
                val keyri = Keyri(this@MainActivity, appKey, publicApiKey, serviceEncryptionKey)

                keyri.initiateQrSession(sessionId, publicUserId)
                    .onSuccess { session ->
                        // You can optionally create a custom screen and pass the session ID there. We recommend this approach for large enterprises
                        val session =
                            keyri.initializeDefaultScreen(supportFragmentManager, session, payload)
                                .getOrThrow()

                        // In a real world example youâ€™d wait for user confirmation first
                        session.confirm(payload) // or session.deny(payload)
                    }

                // Process result
            } catch (e: Throwable) {
                Log.e("Keyri", "Authentication exception $e")
            }
        }
    } ?: Log.e("Keyri", "Failed to process link")
}
```
</Tab>
<Tab>
```java copy
private void scanQr() {
    // Your scanner implementation
    // Get link from QR and process it:
    processLink(uri);
}

private void processLink(@Nullable Uri data) {
    String sessionId = data.getQueryParameters("sessionId").get(0);

    if (sessionId != null) {
        try {
            String appKey = "[Your appKey]"; // Get this value from the Keyri Dashboard
            String publicApiKey = "[Your publicApiKey]"; // Get this optional value from the Keyri Dashboard for Fraud Prevention
            String serviceEncryptionKey =
                "[Your serviceEncryptionKey]" // Get this optional value from the Keyri Developer Portal for Fraud Prevention
            String publicUserId = "public-User-Id"; // publicUserId is optional
            String payload = "Custom payload here";

            // Be sure to import the SDK at the top of the file
            KeyriSdk keyri = new KeyriSdk(this, appKey, publicApiKey, serviceEncryptionKey);

            keyri.initiateQrSession(sessionId, publicUserId, new KeyriCallback<>() {
                @Override
                public void onComplete(KeyriSession result) {
                    // You can optionally create a custom screen and pass the session ID there. We recommend this approach for large enterprises
                    keyri.initializeDefaultConfirmationScreen(
                        getSupportFragmentManager(),
                        result,
                        payload,
                        new KeyriCallback<>() {
                            @Override
                            public void onComplete(String result) {
                                // Process result
                            }

                            @Override
                            public void onError(@Nullable Throwable throwable) {
                                // Process error
                            }
                        });

                    // In a real world example youâ€™d wait for user confirmation first
                    result.confirm(payload, this, true, new KeyriCallback<String>() {
                        @Override
                        public void onComplete(String result) {
                            // Process result
                        }

                        @Override
                        public void onError(@Nullable Throwable throwable) {
                            // Process error
                        }
                    }); // or session.deny(payload)
                }

                @Override
                public void onError(@Nullable Throwable throwable) {
                    // Process error
                }
            });
        } catch (Throwable e) {
            Log.e("Keyri", "Authentication exception $e");
        }
    } else {
        Log.e("Keyri", "Failed to process link");
    }
}
```
</Tab>
</Tabs>

### Jetpack Compose support

Add Keyri Compose dependency to your module `build.gradle` file and sync project:

```kotlin copy
dependencies {
    // ...
    implementation("com.keyri:keyrisdk:$latestKeyriVersion")
    implementation("com.keyri:compose:$latestKeyriVersion")
}
```

Use `ScannerPreview` for retrieving sessionId from scanned QR code. All you need here to provide is:

- `modifier: Modifier` - modifier object to change the appearance of the ScannerPreview.

- `onScanResult: (Result<String>)` - callback for handling sessionId.

- `onClose: () -> Unit` - callback for handling close button.

- `isLoading: Boolean` - value to show progress bar.

After you receive `Session` object you can create your own confirmation dialog or use
default: `ConfirmationModalBottomSheet`. Provide next arguments:

- `modalBottomSheetState: ModalBottomSheetState` - state to to manage BottomSheet.

- `coroutineScope: CoroutineScope` - coroutine scope for suspending calls inside BottomSheet.

- `session: Session?` - session object to process \(should not be null when modalBottomSheetState is shown\).

- `payload: String` - can be anything (session token or a stringified JSON containing multiple items. Can include things like publicUserId, timestamp, customSignedData and ECDSA signature).

- `onResult: (Result<Boolean>)` - callback for handling result of user confirmation.

To handle deeplink with default confirmation screen you can use `EasyKeyriAuth `composable:

```kotlin copy
val coroutineScope = rememberCoroutineScope()

val modalBottomSheetState = rememberModalBottomSheetState(
    initialValue = ModalBottomSheetValue.Hidden,
    skipHalfExpanded = true
)

EasyKeyriAuth(
    modalBottomSheetState,
    coroutineScope,
    keyri,
    sessionId,
    "Custom payload here",
    "public-User-Id" // publicUserId is optional
) { result ->
    // Process result
}
```

## Interacting with the API

The following methods are available to interact with the Keyri SDK API, which can be used to craft your own custom flows and leverage the SDK in different ways:

### Kotlin

- `suspend fun Keyri.initializeQrSession(sessionId: String, publicUserId: String?): Result<Session>`: call it after obtaining the sessionId from QR code or deep link. Returns result of Session object with Risk attributes (needed to show confirmation screen) or Throwable error

- `suspend fun Keyri.initializeDefaultConfirmationScreen(fm: FragmentManager, session: Session, payload: String, publicUserId: String?): Result<Unit>`: to show Confirmation with default UI. Returns Boolean result or Throwable error. Also, you can implement your custom Confirmation Screen, just inherit from BaseConfirmationDialog.kt

- `suspend fun Session.confirm(payload: String, context: Context, trustNewBrowser: Boolean, publicUserId: String?): Result<Unit>`: call this function if user confirmed the dialog. Returns Boolean authentication result or Throwable error

- `suspend fun Session.deny(payload: String, context: Context, trustNewBrowser: Boolean): Result<Unit>`: call if the user denied the dialog. Returns Boolean denial result or Throwable error

- `suspend fun Keyri.processLink(fragmentManager: FragmentManager, url: Uri, payload: String, publicUserId: String?): Result<Unit>`: process flow with passed uri with showing default confirmation screen. Easiest way to process session from deeplink. Returns Boolean result of authentication or Throwable error

- `suspend fun Keyri.sendEvent(publicUserId: String = ANON_USER, eventType: EventType, success: Boolean): Result<FingerprintEventResponse>`: send fingerprint event and event result for specified publicUserId's.

- `suspend fun Keyri.generateAssociationKey(publicUserId: String = "ANON"): Result<String>`: creates a persistent ECDSA keypair for the given publicUserId (example: email address) or default without arguments and return Base64 string public key

- `suspend fun Keyri.generateUserSignature(publicUserId: String = "ANON", data: String): Result<String>`: returns an ECDSA signature of custom data for sign with the custom publicUserId's privateKey (or, if not provided, anonymous privateKey), customSignedData can be anything

- `suspend fun Keyri.listAssociationKey(): Result<Map<String, String>>`: returns a map of "association keys" and ECDSA Base64 public keys.

- `suspend fun Keyri.listUniqueAccounts(): Result<Map<String, String>>`: returns a map of unique "association keys" and ECDSA Base64 public keys.

- `suspend fun Keyri.getAssociationKey(publicUserId: String = "ANON"): Result<String>`: returns association Base64 public key for the specified publicUserId (or, if not provided, for anonymous)

- `suspend fun Keyri.removeAssociationKey(publicUserId: String = "ANON"): Result<Unit>`: removes association public key for the specified publicUserId (or, if not provided, for anonymous)

- `fun easyKeyriAuth(content: Context, easyKeyriAuthLauncher: ActivityResultLauncher<Intent>, appKey: String, publicApiKey: String?, serviceEncryptionKey: String?, payload: String, publicUserId: String?)`: launches scanner activity with default confirmation screen for ActivityResultLauncher

- `fun easyKeyriAuth(activity: Activity, requestCode: Int, appKey: String, publicApiKey: String?, serviceEncryptionKey: String?, payload: String, publicUserId: String?)`: launches scanner activity for result with default confirmation screen for onActivityResult

- `@Composable fun EasyKeyriAuth(sheetState: ModalBottomSheetState, coroutineScope: CoroutineScope, keyri: Keyri, url: Uri, payload: String, publicUserId: String?, result: (Result<Unit>) -> Unit)`: handle process flow with passed scanned url and showing default confirmation screen. Easiest way to process session from deeplink

- `@Composable fun ConfirmationModalBottomSheet(modalBottomSheetState: ModalBottomSheetState, coroutineScope: CoroutineScope, session: Session? = null, publicUserId: String?, payload: String, onResult: (Result<Unit>) -> Unit)`: to show Confirmation with default UI. Returns Boolean result or Throwable error

- `@Composable fun ScannerPreview(modifier: Modifier = Modifier, onScanResult: (Result<String>) -> Unit = {}, onClose: () -> Unit = {}, isLoading: Boolean = false)`: default QR scanner implementation based on ML Kit. Returns result of scanning (string sessionId or error)

Payload can be anything (session token or a stringified JSON containing multiple items. Can include things like publicUserId, timestamp, customSignedData and ECDSA signature)


### Java

- `void Keyri.initializeQrSession(String sessionId, String publicUserId, KeyriCallback<KeyriSession> callback)`: call it after obtaining the sessionId from QR code or deep link. Returns result of Session object with Risk attributes (needed to show confirmation screen) or Throwable error

- `void Keyri.initializeDefaultConfirmationScreen(FragmentManager fm, KeyriSession session, String payload, String publicUserId, KeyriCallback<Unit> callback)`: to show Confirmation with default UI. Returns Boolean result or Throwable error. Also, you can implement your custom Confirmation Screen, just inherit from BaseConfirmationDialog.kt

- `void KeyriSession.confirm(String payload, Context context, boolean trustNewBrowser, String publicUserId, KeyriCallback<Unit> callback)`: call this function if user confirmed the dialog. Returns Boolean authentication result or Throwable error

- `void KeyriSession.deny(String payload, Context context, boolean trustNewBrowser, KeyriCallback<Unit> callback)`: call if the user denied the dialog. Returns Boolean denial result or Throwable error

- `void Keyri.processLink(FragmentManager fragmentManager, Uri url, String payload, String publicUserId, KeyriCallback<Unit> callback)`: process flow with passed uri with showing default confirmation screen. Easiest way to process session from deeplink. Returns Boolean result of authentication or Throwable error

- `void Keyri.sendEvent(String publicUserId, EventType eventType, boolean success, KeyriCallback<FingerprintEventResponse> callback)`: send fingerprint event and event result for specified publicUserId's.

- `void Keyri.generateAssociationKey(String publicUserId, KeyriCallback<String> callback)`: creates a persistent ECDSA keypair for the given publicUserId (example: email address) or default without arguments and return Base64 string public key

- `void Keyri.generateUserSignature(String publicUserId, String data, KeyriCallback<String> callback)`: returns an ECDSA signature of custom data for sign with the custom publicUserId's privateKey (or, if not provided, anonymous privateKey), customSignedData can be anything

- `void Keyri.listAssociationKey(KeyriCallback<Map<String, String>> callback)`: returns a map of "association keys" and ECDSA Base64 public keys.

- `void Keyri.listUniqueAccounts(KeyriCallback<Map<String, String>> callback)`: returns a map of unique "association keys" and ECDSA Base64 public keys.

- `void Keyri.getAssociationKey(String publicUserId, KeyriCallback<String> callback)`: returns association Base64 public key for the specified publicUserId (or, if not provided, for anonymous)

- `void Keyri.removeAssociationKey(String publicUserId, KeyriCallback<Unit> callback)`: removes association public key for the specified publicUserId (or, if not provided, for anonymous)

- `void EasyKeyriAuth.easyKeyriAuth(Context content, ActivityResultLauncher<Intent> easyKeyriAuthLauncher, String appKey, String publicApiKey, String payload, String publicUserId)`: launches scanner activity with default confirmation screen for ActivityResultLauncher

- `void EasyKeyriAuth.easyKeyriAuth(Activity activity, int requestCode, String appKey, String publicApiKey, String payload, String publicUserId)`: launches scanner activity for result with default confirmation screen for onActivityResult

### Session Object

The session object is returned on successful `initializeQrSession` calls, and is used to handle presenting the situation to the end user and getting their confirmation to complete authentication. Below are some of the key properties and methods that can be triggered. If you are utilizing the built-in views, you are only responsible for calling the confirm/deny methods above

- iPAddressMobile/Widget - The IP Address of both mobile device and web browser

- riskAnalytics - if applicable

- riskStatus - clear, warn or deny

- riskFlagString - if RiskStatus is warn or deny, this string alerts the user to what is triggering the risk situation

- geoData - Location data for both mobile and widget

- mobile

- city

- country_code

- browser

- city

- country_code

- mobileTemplateResponse - Use this object to define confirmation screen UI

- `Session.confirm()` and `Session.deny()` - see descriptions in **Interacting with the API**.

# Disclaimer

We care deeply about the quality of our product and rigorously test every piece of functionality we offer. That said, every integration is different. Every app on the App Store has a different permutation of build settings, compiler flags, processor requirements, compatibility issues etc and it's impossible for us to cover all of those bases, so we strongly recommend thorough testing of your integration before shipping to production. Please feel free to file a bug or issue if you notice anything that seems wrong or strange on GitHub ðŸ™‚

https://github.com/Keyri-Co/keyri-android-whitelabel-sdk/issues
